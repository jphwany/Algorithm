/*
    Q) 가지고 있는 동전 1원, 5원, 10원, 50원, 100원, 500원으로
    개수를 최소화하여 거스름돈 K를 만들어라
    단, 동전은 오름차순이며 서로 배수 관계에 있다

    input args_1 : int 타입의 k. 1 <= k <= 100,000,000
    output : int 타입의 거스름돈 k원을 만드는데 필요한 동전 개수의 최소값

 */


package greedyAlgorithm;

public class SolutionGreedyCountChange {
    public int countChange(int k){

        int[] coin = new int[]{500, 100, 50, 10, 5, 1};
        // 동전 배열 생성, 내림차순.  for문은 큰 수부터 도는게 효율적이니까

        int count = 0; // 필요한 동전의 최소 개수 0으로 초기화

        for(int i = 0; i < coin.length; i++){
            count += k / coin[i];
            k %= coin[i];
/*
        입력 받는 k 거스름돈을 i번째 동전을 나누어서 그 몫에 해당하는 값인 동전 개수를 count에 더하여 저장
        k를 i번째 동전으로 나눈 나머지를 다시 k에 할당을 해주면 다음 반복 때 그 다음 수로 똑같은 로직을 수행하게되고
        결국 끝까지 반복을 하면 동전 최소 개수가 리턴된다
*/
        }
        return count;
    }
}
/*
    k 거스름돈을 12,345원이라고 가정하면
    500원부터 반복문이 실행될텐데
    12345/500 = 24.69, 몫은 24니까
    count에 24가 할당된다
    그리고 12345를 500으로 나눈 나머지 345를 k에 할당

    그리고 다음 i인 100으로 위 로직을 똑같이 실행
    첫 반복에 할당된 k 345를 100으로 나누면 몫은 3이니까 3을 더해줘서 누적된 count는 27
    345를 100으로 나눈 나머지 45를 k에 다시 할당

    45를 다음 i인 50으로 위 로직을 실행하려고 보니 몫이 0이 나와버리고 count에 0을 더해준다(50원짜리는 패싱이라는 의미)
    45를 50으로 나눈 나머지는 몫을 0으로 두었을 때 소수점으로 나타나면서 나누어 떨어지기 때문에 이 또한 패싱
    여전히 45인 상태로

    다음 i번째인 10으로 로직 수행
    45를 10으로 나누면 몫은 4, 나머지는 5
    count에 4 더해주고
    나머지 5를 k에 할당

    다음 i번째인 5로 로직 수행
    5를 5로 나누면 몫은 1, 나누어떨어진다
    count에 1를 더해주고
    나누어 떨어졌기 때문에 패싱

    k가 0원이기 때문에 더이상 로직이 의미가 없고
    그렇게 coin 배열 다 순회하고 반복문이 종료된다

    그러고 count 리턴

    24 + 3 + 4 + 1 = 32
 */