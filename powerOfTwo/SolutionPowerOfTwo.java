/*
    Q) 수를 입력 받아 2의 거듭제곱인지 여부 리턴

    input) args_1 : num(long 타입의 정수) >= 1
    output) boolean

    [caution]
    1. 반복문 while문을 사용
    2. 2의 0제곱은 1
    3. Math.log 사용 금지
*/
package powerOfTwo;

public class SolutionPowerOfTwo {
    public boolean powerOfTwo(long num) {

        if (num == 1) {
            return true;
        }
        // 1은 2의 0제곱이므로 항상 true


        while (num > 1) {
            if (num % 2 == 0) {
                num /= 2;
            } else {
                return false;
            }
        }

        return true;

        /*
         num이 1보다 클 경우 반복
         2로 나누어 떨어졌을 경우 2로 나눠서 num에 할당, 다시 반복한다
         2로 나누어 떨어진다고해도 그건 짝수지 항상 2의 거듭제곱일 수는 없다

         100을 입력받는다고 한다면 짝수이기 때문에 2로 나누어 떨어지지만
         2의 거듭제곱은 아니기 때문에 2로 나누고 난 뒤 50을 다시 num에 할당하고
         50도 2로 나누어 떨어지기 때문에 다시 2로 나눈 25를 다시 num에 할당
         25는 2으로 나누어 떨어지지 않으니까 else 문의 리턴인 false로 끝나게된다

         32를 입력받는다고 하면 2로 나누어 떨어지기 때문에 2로 나눈 16을 다시 할당하고 반복
         16도 2로 나누어 떨어지기 때문에 2로 나누고 8을 다시 할당하고 반복
         8도 2로 나누어 떨어지기 때문에 2로 나누고 4를 다시 할당, 반복
         4도 2로 나누어 떨어지기 때문에 2로 나누고 2를 다시 할당, 반복
         2도 2로 나누어 떨어지기 때문에 2로 나누면 1이 나오고
         while 조건인 num > 1을 벗어나기 때문에 while 문이 종료되고

         powerOfTwo의 리턴 값인 true를 반환하게 된다

         즉, 주어진 수를 계속 2로 소인수 분해하는 경우에만 true를 반환한다는 의미와 같다
         왜냐하면 반복하면서 2로 나누어 떨어지지 않는 경우는 전부 else문의 false로 반환하기 때문에
         최소 단위인 1까지 검사하며 반환한다 1까지 검사한다는 건 그 전의 모든 요소가 2라는 소리다 2*2*2*2...*1 이렇게 나온다
         결국 그건 인수가 2로만 되어있는 2의 거듭제곱이라는 소리다

         */
     }
}

/*
     num을 소인수분해를 했을 때 그 요소가 2로만 되어있다면 2의 거듭제곱이다
     num을 2로 나누었을 때 나누어 떨어지면 그 수는 그냥 짝수지 거듭제곱까진 아니다
	 만약 num이 짝수 일 경우, 그 수를 소인수 분해 했을 때 인수가 2로만 이루어져 있다면?
	 2의 거듭제곱이다

*/
